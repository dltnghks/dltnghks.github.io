---
layout: post
title: "발전소"
date: 2026-02-04 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image](/assets/img/posts/2026-02-04-발전소/2fb28fef-de90-817b-9450-fd8753873c7a.png)


[1102번: 발전소](https://www.acmicpc.net/problem/1102)


## 어떤 걸 사용하나요?


조건에 맞는 최소 비용을 찾기 위해서 작은 단위부터 탐색하면서 올라와야 한다. 이 문제의 경우 활성화되어야 하는 발전소 수가 정해져 있고, 번호에 따라 달라지기 때문에 현재 활성화된 발전소를 상태로 가져야 한다.


현재 활성화 시킨 발전소 상태만 알면 되기 때문에 1차원 배열로 관리를 하게 되는데, 상태 표현을 위해 비트마스킹을 사용한다.


## 어떻게 구현하나요?


```c#
1. 상태(State): bitmask (켜진 발전소 집합)
2. 정의(DP): dp[state] = 현재 state에서 P개까지 켜는 최소 비용
3. 전이(Transition):
   for (i : 켜진 놈) 
     for (j : 꺼져있는 놈)
       min_cost = min( min_cost, solve(state | 1<<j) + Cost[i][j] )
```


```c#
#include <iostream>
#include <cstring>

#define INF 1e9

using namespace std;

int graph[16][16];
int dp[1 << 16];
int initState;
int p, n;

int CountBit(int bit){
    int count = 0;
    while(bit != 0){
        if(bit & 1){
            count++;
        }
        bit = bit >> 1;
    }
    return count;
}

int solve(int state){
    // p 개수만큼 활성화가 되었다면 리턴
    if(CountBit(state) >= p){
        return 0;
    }

    // 메모제이션
    if(dp[state] != -1){
        return dp[state];
    }

    dp[state] = INF;

    for(int i = 0; i < n; i++){
        // 활성화된 발전소 확인
        if(!(state & (1 << i)))
            continue;

        for(int j = 0; j < n; j++){
            // 비활성화된 발전소 찾기
            if(state & (1 << j))
                continue;

            int nextState = state | (1 << j);
            int nextCost = solve(nextState) + graph[i][j];
            dp[state] = min(dp[state], nextCost);
        }
    }

    return dp[state];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    cin >> n;

    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            cin >> graph[i][j];
        }
    }

    string s;
    cin >> s;
    for(int i = 0; i < s.length(); i++){
        if(s[i] == 'N')
            continue;
        
        initState |= (1 << i);
    }

    cin >> p;

    // 예외 처리
    if(CountBit(initState) >= p){
        cout << 0;
        return 0;
    }

    memset(dp, -1, sizeof(dp));

    cout << solve(initState) << '\n';
    return 0;
}
```

