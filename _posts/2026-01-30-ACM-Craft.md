---
layout: post
title: "ACM Craft"
date: 2026-01-30 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image](/assets/img/posts/2026-01-30-ACM-Craft/f274fa15881348441bb1620e08d4ef25.png)


[1005번: ACM Craft](https://www.acmicpc.net/problem/1005)


### 어떤 걸 사용하나요?


위상정렬을 이용하면 된다.


![image](/assets/img/posts/2026-01-30-ACM-Craft/9718961a52b94e6d885051be99b91ba2.png)

1. 정렬 조건이 상대적이다.
2. 방향성이 있다.

는 조건을 만족하기 때문에 위상정렬을 사용했다.


다만 여기에 건설 시간이 추가되었기 때문에 이를 처리할 방법을 생각해야 한다.


4번 건물이 건설되기 위한 조건은 2와 3이다. 각각 1초, 100초를 가지고 있지만 결국 기다려야 하는 것은 3번(가장 늦게 건설되는 건물)이다.


따라서 건물이 생성될 때, 앞으로 생성될 건물의 시간을 업데이트하되 가장 오래 걸리는 시간을 유지하도록 하면 된다.


### 어떻게 구현하나요?


위상정렬과 동일하나 중간에 시간을 처리하는 과정이 들어간다.

1. 입력을 받으면서 `inDegree` 를 업데이트한다.
2. `inDegree`가 0인 건물들을 큐에 넣는다.
    1. 넣으면서 시작 건물의 건설 시간을 `usedTimes` 에 기록한다.
3. 큐에서 건설할 건물들을 하나씩 뺀다.
4. `next` 건물들의 `inDegree` 를 -1한다.
    1. `next` 건물의 `usedTimes` 를 업데이트한다.
        1. 가장 큰 수를 유지하도록 한다.
5. inDegree가 0인 건물은 큐에 넣는다.

```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main() {

    int t;
    cin >> t;

    for(int i = 0; i < t; i++){
        int n, k;
        cin >> n >> k;
        vector<int> times(n+1);
        vector<int> usedTimes(n+1, 0);

        for(int j = 1; j <= n; j++){
            cin >> times[j];
        }

        vector<vector<int>> graph(n+1, vector<int>());
        vector<int> inDegree(n+1, 0);
        for(int j = 0; j < k; j++){
            int x, y;
            cin >> x >> y;
            graph[x].push_back(y);
            inDegree[y]++;
        }

        int w;
        cin >> w;


        int totalTime = 0;

        queue<pair<int, int>> q;
        for(int j = 1; j <= n; j++){
            if(inDegree[j] == 0){
                q.push({j, times[j]});
                usedTimes[j] = times[j];
            }
        }

        while(!q.empty()){
            int cur = q.front().first;
            int curTime = q.front().second;
            q.pop();

            for(int next : graph[cur]){
                inDegree[next]--;
                usedTimes[next] = max(usedTimes[next], curTime + times[next]);
                    
                if(inDegree[next] == 0){
                    q.push({next, usedTimes[next]});
                }
            }
        }


        cout << usedTimes[w] << '\n';
    }
    

    return 0;
}
```

