---
layout: post
title: "MST(최소 스패닝 트리)"
date: 2026-01-28 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ee17cf06-43f2-486f-8559-6db5e83a2d4f/6c8561a8-c2b1-4803-b885-ef3390ec1536/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466ZZQYKAEZ%2F20260129%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260129T125708Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIFfVki8Loc%2FXx3xTwqAoqmUdBVKbPP4hhL5sL%2FOxzNNhAiEAnii297PuDkRreTJf7I1mczIJdzEqa6fIAxqme0mSgcEqiAQIhf%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARAAGgw2Mzc0MjMxODM4MDUiDMX0ctLmWP9hfdzpoircA8Se20w3qpLFSfMaHYFhCbwIBP66VQWTDiQdETisSC9VwsCe02FGb9z1zJO3RACNlGHv5n%2FkkevehmYB4WC%2FkCw6jkUqr%2F9CFEDaG6knKph2h8u3v7vUU8MCEHvy77SxGGTVIRx03cq%2FXD%2ByOISp9OjQVcmcsJaqFJk3ODpKaM0nYPAQMghGdwQxiGyozGlj24PjDABuN26TlDYChaz3Uhvczcd9uh0hex2qssQA0kduM%2B2pG3cd9TP64kvlvflOuTUUOYY0ph11RFmpfjn%2FAKpKa0ZQmpXC2GsR9nExpRYHAdURB1l%2BWS0sWxnsXe6%2BHimWFnYlvl%2B%2FnAuO%2FnS%2FqcIsTn6k0IAx%2BmtMr%2BJJxLmVN6lnf5L4TGVS4i7pDvDrUzIKi%2BwdIxliu%2F6TSOOoV%2FXRDX8ZlU%2F2K1%2BH%2BJsl%2BlFVKLe%2BQVsOAa6OfGgPf94JqUh6KcmVv3Xsdwlkbt86AWGMSE4eXt2RpDU2WgXTv6dOcU8L2pR6xL6HLwGplXxf8rhWArml7E0frTZNpbsp%2BS6TBJIkwHyro3uPs%2BZ0%2BmBiJndhYEGq7Ik87%2FS%2FHODSL08rvyUqE38NuYGCnI6rxtd9jCCxIRrcuwg3d9Xd6mZrT3UOTLaETNqeNKuVMI2U7csGOqUBrvqOz6uK2%2Bkms4hXB7hptGdumsqjAYOOroPEjheXh10bQLgaYcB6ceKd3zmZ9%2FoE%2BDE9rr5voNMItwPlGC0pDlOv7v%2FGa2ouQJc23yqGDIbnyEqzgu9M%2BjKAR8ZwdQm2tHcfPm4BBynWlWIT8QHSFmd4tjY4Koq65%2FUU3ytD6rExo%2F5596vFa5fO9C9BoKjS%2FYSkUVzCH714Qi87FgofU0Wh1M8d&X-Amz-Signature=e4a2cc6165b521bdf8165a2c8465155ce27a1f9ce745bc77d21894feac80ea22&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


[1197번: 최소 스패닝 트리](https://www.acmicpc.net/problem/1197)


### MST?


최소 스패닝 트리(MST)는 아래의 두 조건을 만족해야 한다.

1. 모든 정점이 연결되어야 한다.
2. 연결되는 간선의 비용이 최소가 되어야 한다.

왜 트리인가?

- 사이클이 없기 때문이다.

### 어떻게 구현하나요?


가장 쉽고 유명한 방법은 크루스칼(Kruskal) 알고리즘이다.

1. 정렬 : 모든 간선을 비용이 낮은 순서대로 정렬한다.
2. 선택 : 가장 가중치가 낮은 간선부터 하나씩 선택
3. 검사
    - 이 간선을 연결했을 때, 사이클이 생기는가?

    NO → 연결


    YES → 버린다.

4. 모든 정점이 연결될 때까지 반복한다.

### 유니온 파인드(Union-Find)


크루스칼 알고리즘을 사용하기 위해서는 사이클 검사를 수행해야 한다. 이때 사용하는 자료구조가 바로 Union-Find이다.

- `Find(x)`: x가 속한 그룹의 부모가 누구인지 찾기.
- `Union(a, b)`: a와 b를 **같은 그룹으로 합치기.**
1. 간선 A-B를 선택
2. Find(A)와 Find(B)를 비교

    같다 → 이미 연결됨. 패쓰


    다르다 → Union(A, B)를 수행하고 비용 추가


```c++
int find(int x) {
    if (parent[x] == x) return x;
    // 찾으면서 부모를 갱신해줘야 됨.
    return parent[x] = find(parent[x]); 
}

void merge(int a, int b){
    int rootA = find(a); 
    int rootB = find(b); 
    
    // 각 정점의 부모를 찾은 후, 통합
    if(rootA != rootB){
        parent[rootB] = rootA; 
    }
}
```


### MST 구현


```c++
#include <iostream>
#include <vector>
#include <algorithm> // sort 사용

using namespace std;

// 간선 정보 저장용 구조체
struct Edge {
    int u, v, w;
    // 가중치(w) 기준 오름차순 정렬을 위한 연산자 오버로딩
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
};

int parent[10001];

int find(int x) {
    if (parent[x] == x) return x;
    return parent[x] = find(parent[x]); 
}

void merge(int a, int b){
    int rootA = find(a); 
    int rootB = find(b); 
    
    if(rootA != rootB){
        parent[rootB] = rootA; 
    }
}

int main() {
    // 1. 입력 받기
    int V, E;
    cin >> V >> E;
    
    // parent 초기화
    for(int i = 1; i <= V; i++) parent[i] = i;
    
    vector<Edge> edges;
    for(int i = 0; i < E; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        edges.push_back({u, v, w});
    }
    
    // 2. 간선 정렬 (가중치 작은 순서대로)
    sort(edges.begin(), edges.end());
    
    // 3. 크루스칼 알고리즘 수행
    int totalWeight = 0;
    int edgeCount = 0; // 연결된 간선 개수 카운트 (선택 사항이지만 최적화용)
    
    for(int i = 0; i < edges.size(); i++) {
        // 싸이클이 발생하지 않는다면 합치기
        int a = edges[i].u;
        int b = edges[i].v;
        int cost = edges[i].w;
        if(find(a) != find(b)){
            totalWeight += cost;
            merge(a, b);
        }
    }
    
    cout << totalWeight;
    
    return 0;
}
```

