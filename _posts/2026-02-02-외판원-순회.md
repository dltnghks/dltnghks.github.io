---
layout: post
title: "외판원 순회"
date: 2026-02-02 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image](/assets/img/posts/2026-02-02-외판원-순회/2fb28fef-de90-8105-88fc-eda5398677c7.png)


[https://www.acmicpc.net/problem/2098](https://www.acmicpc.net/problem/2098)


## 어떤 걸 사용하나요?

> 1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 **순회 여행 경로**를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

입력

> 첫째 줄에 도시의 수 N이 주어진다. **(2 ≤ N ≤ 16)** 다음 N개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.

### DP


N이 16으로 $16! \approx 20,922,789,888,000$(약 20조 번) 연산이 요구된다.


이를 모두 수행할 수 없다. 


⇒ **같은 상태(방문한 도시들 + 현재 위치)**에 더 적은 비용으로 도달한 적이 있다면, 그 이후는 계산하지 않고 버려야한다.


### Bit mask


DP를 하려면 **현재 상태**를 저장해야 하는데, 여기서 상태는 두 가지다.

1. **지금 어디에 있는가?** (예: 3번 도시)
2. **지금까지 어디를 방문했는가?** (예: 1번, 2번 방문함)

여기서 2번(방문 기록)을 저장할 때, 비트마스킹을 사용한다.


도시가 16개일 때, 배열 `bool visited[16]`을 쓰면 DP 배열을 만들 수 없다.(`dp[16][배열]`은 불가능)


대신, `1번, 2번 방문` $\rightarrow 00...00011 \rightarrow $ **십진수 3**


즉, **`dp[현재도시][3]`** 처럼 정수로 깔끔하게 상태를 저장할 수 있게 된다.


## 어떻게 구현하나요?


비용 행렬을 나타내는 graph와 비트마스킹을 활용한 dp를 사용한다.


1번 도시에서 출발해서 다시 1번 도시로 돌아와야 한다.


DFS를 통해 경로를 탐색하고, DP로 가지치기하는 방식을 사용한다.

1. 출발지(1)에서 시작
    - 스택에 푸쉬
2. 스택에서 하나씩 빼기
    - 현재 위치에서 갈 수 있는 곳을 확인
    - 다음으로 가는 비용이 기존에 기록된(dp)보다 적은 경우에만 새롭게 푸쉬
3. 모든 경로를 탐색한 경우 result 최솟값으로 갱신

```c++
#include <iostream>
#include <vector>
#include <stack>

#define INF 1e9

using namespace std;

struct State {
    int cur;      // 현재 도시
    int path;     // 방문 비트마스크
    int cost;     // 현재까지 비용
};

int main() {
    int n;
    cin >> n;

    vector<vector<int>> graph(n+1, vector<int>(n+1));
    vector<vector<int>> dp(1 << (n+1), vector<int>(n+1, INF));

    for(int i= 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            cin >> graph[i][j];
        }
    }
    
    stack<State> s;
    int result = INF;
    s.push({1,(1 << 1), 0});
    dp[1 << 1][1] = 0;

    while(!s.empty()){
        int cur = s.top().cur;
        int curPath = s.top().path;
        int curCost = s.top().cost;
        s.pop();

        if(dp[curPath][cur] < curCost) continue;

        // 모든 경로를 다 돌았으면?
        if((curPath == (1 << n+1) - 2)){
            if(graph[cur][1] != 0){
                result = min(result, curCost + graph[cur][1]);
            }
            continue;
        }

        for(int next = 2; next <= n; next++){
            // 1. 길이 있어야 하고
            // 2. 아직 방문하지 않았어야 함.
            if(graph[cur][next] != 0 && !(curPath & (1 << next))){
                int nextPath = curPath | (1 << next);
                int nextCost = curCost + graph[cur][next];
                
                if(dp[nextPath][next] > nextCost){
                    dp[nextPath][next] = nextCost;
                    s.push({next, nextPath, nextCost});
                }
            }
        }
    }

    cout << result << '\n';

    return 0;
}
```

