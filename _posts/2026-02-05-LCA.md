---
layout: post
title: "LCA"
date: 2026-02-05 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image](/assets/img/posts/2026-02-05-LCA/2fe28fef-de90-808c-a0c2-f3c53758cd85.png)


[11437번: LCA](https://www.acmicpc.net/problem/11437)


## 어떤 걸 사용하나요?


두 노드의 가장 가까운 공통 조상이 몇 번인지 출력하기 위해서는 각 노드 별로 공통 조상 노드가 어떤 건지 알아야 한다?
Depth를 기준으로 위로 올라가면 된다.


## 어떻게 구현하나요?


필요한 상태 정보 - Parent, Depth

1. 트리 구조로 새롭게 변경
2. 노드 쌍이 들어올 때, Depth를 비교
    - a와 b가 들어왔을 때, 둘의 depth을 맞추고 똑같은 노드가 될 때까지 위로 올라간다. O(N)

코테에서는 최대한 배열로 그냥 만들자.
vector로 만드니까 시간 초과가 발생했다.
=> 배열로 변경하니까 통과!

- **벡터:** 힙(Heap) 메모리에 할당되고, 크기가 변할 때 재할당 비용이 듭니다. 특히 `struct` 안에 `vector`를 넣으면, 노드 개수($N$)만큼 벡터를 생성해야 해서 초기화 시간이 꽤 걸린다.
- **배열:** 전역 변수로 선언하면 컴파일 타임에 메모리가 잡히므로 실행 시 오버헤드가 거의 없다.

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// 문제 조건에 따라 최대 노드 수 설정 (LCA 2 기준 10만, LCA 1 기준 5만)
const int MAX_N = 100001;

int parent[MAX_N];
int depth[MAX_N];

// graph[i]는 i번 노드와 연결된 노드들의 리스트
vector<int> graph[MAX_N];

void MakeTree(int cur, int p, int dep){
    depth[cur] = dep;
    parent[cur] = p; // cur의 부모는 p

    // graph[cur]는 벡터이므로 range-based for 사용 가능
    for(int child : graph[cur]){
        if(child == p) continue;
        MakeTree(child, cur, dep+1);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    cin >> n;

    // 그래프 입력
    for(int i = 0; i < n-1; i++){
        int a, b;
        cin >> a >> b;
        graph[a].push_back(b);
        graph[b].push_back(a);
    }

    // 트리 생성
    MakeTree(1, 0, 0);

    int m;
    cin >> m;
    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;

        // 1. 깊이 맞추기 (한 칸씩 이동 - O(N))
        while (depth[a] > depth[b]) a = parent[a];
        while (depth[b] > depth[a]) b = parent[b];

        // 2. 같이 올라가기 (한 칸씩 이동 - O(N))
        while (a != b) {
            a = parent[a];
            b = parent[b];
        }
        cout << a << '\\n';
    }

    return 0;
}
```

