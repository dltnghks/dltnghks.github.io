---
layout: post
title: "위상정렬"
date: 2026-01-29 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ee17cf06-43f2-486f-8559-6db5e83a2d4f/6c8561a8-c2b1-4803-b885-ef3390ec1536/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662FOB7AGP%2F20260129%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260129T184534Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEML%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJGMEQCIDQJsX23QQ0onYJir5S9NLLC8tDZAxsBY9%2BXTdwdRlQ7AiBE4MZHdtZZD8f2Vesrz25Y3tdsm8XneVH6Dlm1pVVBwSqIBAiL%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F8BEAAaDDYzNzQyMzE4MzgwNSIMPhqUzh3IcJIslgdDKtwDMzEWHl3BJS6w1FdiJttgKvSjLpvEtgnCJi%2BNTaFrM0iNdfiDPtfm1kygkzfivMD%2BhONnSJpbavlEee5h78s5PxD2eaHOnjWFDpccSSRiNwjfR7SfjV7iMQjLHaiXXOQObVsLfFKHcK6KmiM0Dwitv0N5C4MUiZX98yvV1xp%2BCxFeNeOkfwC%2FsGhDCfTuDCcSwzK40bD8%2Bp6vxNHtvDXJ8VYvFMcSUgKgw7TJQEVkzjCCSuStfaeIFl3IgfoVgTLvkXFK1k7B%2BVKve1UoQp3lBJz1lfaIsQUpU%2FV%2F6XZZ%2BV8HhRgc4fcjXzN%2BbsGeBk8y0iYXdYUcO2GkecMKvbGTFlNjAZgzOULrJiFSmc56rDxC9qPJ3%2BR9TjsTXO0tXFPPl2lOqEj0T%2FuzgK2GTSZTXhUUDR%2B88EkvpfCa8rQTvreJWjqt2sulearMTB6ZQh3Eb8ul3%2Brnplkeip%2B33oGM7itQpceSl9ahN60n7xYSLxXr91NjUauuR4aZIj4N53tDU2v6lWySkfzip3ucVeGAdhaEqDLpwkM4rfgHZdkVxQWdRoUcHBNkJkmKvoKAgd6xUcZ%2FBvZVPS97t%2Bf5jVrrs1kAuTHSgqSO9PgHafRBHVnS45UPi%2B41PylKJLMwwcPuywY6pgGgHsID0JMCzhDUSQbPRPUKnxrLC%2BpJP4ZflTvtO28wrM8i600WKKQgTB07pbA7Ci1%2BTS0g%2Bk6a9vAPrtBMla2iVD1PXBukSqKydFAXbYU%2FNNIixCZq6MAHeGl9Ox7deg8XMUGFZPX1paB9HFqYKGCrZk9Lg9px7aNevTUZX2jPktph9q62TeIzo4Yc1SEJiX5MwT4cGZzeHJn7LA4TsYPwGyQfV8KF&X-Amz-Signature=d833487dcc85836e9b9ccca1d56218d7c214945c8a343edcfd0655e2d27989d4&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


[2252번: 줄 세우기](https://www.acmicpc.net/problem/2252)


### 위상정렬?


‘위상’은 물체의 ‘위치’나 ‘형상’의 관계를 뜻한다.


**일반 정렬**

- 기준 : 값의 크기 ( 10 > 5 )
- 결과 : 1, 2, 3, 4, 5 …

**위상 정렬**

- 기준 : 순서와 관계 ( A는 B보다 먼저 해야 한다. )
- 결과 : 답이 여러 개일 수 있다.

위상 정렬이 성립하기 위한 두 가지 조건

1. 방향이 있어야 한다.(Directed)
2. 사이클이 없어야 한다.

    ⇒ 위상 정렬이 가능한 그래프를 DAG(Directed Acyclic Graph)라고 부른다.


### 어떻게 구현하나요?

1. 진입 차수 기록 : 나보다 앞에 서야 하는 사람이 생길 때마다 내 `inDegree` 를 +1 한다.
2. 0명인 사람 찾기 : `inDegree`가 0인 사람은 바로 줄을 서도 된다. ⇒ 큐에 넣는다.
3. 줄 세우기 & 제거
    - 큐에서 한 명(A)를 꺼내어 줄을 세운다.
    - A가 빠졌으니, A뒤에 서기로 헀던 사람(B)들의 `inDegree` 를 1씩 깎아준다.
    - 깎았는데 B의 `inDegree`가 0이 되었다면? B도 큐에 넣는다.

### 위상정렬 구현


```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    
    // 1. 그래프와 진입 차수(inDegree) 테이블 생성
    vector<vector<int>> graph(n + 1);
    vector<int> inDegree(n + 1, 0);

    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        graph[a].push_back(b); // a 뒤에 b가 선다
        inDegree[b]++;         // b의 진입 차수 증가 (내 앞에 한 명 더 생김)
    }

    // 2. 진입 차수가 0인(바로 줄 서도 되는) 학생 큐에 넣기
    queue<int> q;
    for(int i = 1; i <= n; i++){
        if(inDegree[i] == 0) {
            q.push(i);
        }
    }

    // 3. 큐가 빌 때까지 반복 (위상 정렬 수행)
    while(!q.empty()){
        // 1. 큐에서 학생(cur)을 꺼내고 출력한다.
        int cur = q.front();
        cout << cur << " ";
        q.pop();

        // 2. graph[cur]에 연결된 다음 학생(next)들의 inDegree를 1 줄인다.
        for(int next : graph[cur]){
            inDegree[next]--;
            // 3. 만약 inDegree가 0이 된 학생이 있다면 큐에 넣는다.
            if(inDegree[next] == 0){
                q.push(next);
            }
        }
    }

    return 0;
}
```

