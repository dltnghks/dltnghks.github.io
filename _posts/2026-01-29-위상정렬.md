---
layout: post
title: "위상정렬"
date: 2026-01-29 00:00:00 +0900
categories: [Baekjoon]
tags: [C++]
---


![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/ee17cf06-43f2-486f-8559-6db5e83a2d4f/6c8561a8-c2b1-4803-b885-ef3390ec1536/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB466735MJFGM%2F20260129%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260129T125709Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjELz%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDN%2BT46OSTub0D0RvcfrduQXPLN1ZF71XoYgQKLYdv4uwIhAN28fYJ2MIgKugtoAcEoTzl4ElJzVJoDS5IGeakE2zwlKogECIX%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQABoMNjM3NDIzMTgzODA1Igz%2FtKllk9LhzB20Tkcq3AMtCK4%2BDSm4e2UC0dr%2Bq3PaDbllrmDfWyLZXfcWr406uwVoEAfM8I%2BeKr%2BfHt2GbiquBYqMTwZT8%2F7gwBeC4vCDVcnJYrDY2gxbYEqWeHN0RT32ytSu%2BvDo5%2BipggsIdY8d3O2JsGlSE%2FK8%2B5lXYWlNhTVE9h%2BJXdpFOQ%2FsfQRWZIWNEUvaRL37qPVbLO3sjtGSYTyhquf3wiJnXHWLaQaKIhxZ4LwdbiLX4fkCDCGYX4A3WV85qbvOuxe9glFJ1pCCsBZZlx4OAhBXxO3o6oWjDZKUYt34kYxw90PnxRsUaoHwuyDCTEfDk77lRK0RoSFiOKF4qJVRqTg1SAf9B0kUAuIPt1QlyZOyDu7k3zyxZldItEDOpi4Rya2daTtWZw9998u1fenW2BLCPYzBhd0oihwr7OdtZFZjPIWsQjeovyZFNyU3uBFdc%2BX01R6XXdG5Pmpn6gqsvm%2FjuopCR8ifAHJ2CcbBEN8yotoAKkhguxvM3TMHggA04CavpDLfu6fEvDFv1XJO7okNMoadyjrgkMzxobK53QFMIn7sfC3xQ3dmsBcDu114XwyMmEBCVxaGAODVICi4YuhIM926oKaW2urEiR02SyMrIbcH7bQUCD1AskSYN0ZctWjuyzCylO3LBjqkAWXWbvX1gxpqT0rKxX5Opu2mPB8j%2B6ImaKxyPOR1VBxdfxR0S0X32VFqf7v1JNeI7Uf8r4nvHNFdVQQvgDuWdR65oub3v%2FRHl2ULjL0MhUB7eL1RkBMpVBmSAKBmkwj6RHBCCrZq6Qj%2FHQ3zPbh9sMqMRlwKnnHM%2BqhzQ2Myf4AAXjwaQ9Q5%2FkqDG4rSEBpPL6kHbQ8IqU7m5SubCncc8NX%2By%2B8%2F&X-Amz-Signature=5a39dd4ce375a96533e9a2a617245a7efde72e3440333dc9127bfaddaabd8e7e&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)


[2252번: 줄 세우기](https://www.acmicpc.net/problem/2252)


### 위상정렬?


‘위상’은 물체의 ‘위치’나 ‘형상’의 관계를 뜻한다.


**일반 정렬**

- 기준 : 값의 크기 ( 10 > 5 )
- 결과 : 1, 2, 3, 4, 5 …

**위상 정렬**

- 기준 : 순서와 관계 ( A는 B보다 먼저 해야 한다. )
- 결과 : 답이 여러 개일 수 있다.

위상 정렬이 성립하기 위한 두 가지 조건

1. 방향이 있어야 한다.(Directed)
2. 사이클이 없어야 한다.

    ⇒ 위상 정렬이 가능한 그래프를 DAG(Directed Acyclic Graph)라고 부른다.


### 어떻게 구현하나요?

1. 진입 차수 기록 : 나보다 앞에 서야 하는 사람이 생길 때마다 내 `inDegree` 를 +1 한다.
2. 0명인 사람 찾기 : `inDegree`가 0인 사람은 바로 줄을 서도 된다. ⇒ 큐에 넣는다.
3. 줄 세우기 & 제거
    - 큐에서 한 명(A)를 꺼내어 줄을 세운다.
    - A가 빠졌으니, A뒤에 서기로 헀던 사람(B)들의 `inDegree` 를 1씩 깎아준다.
    - 깎았는데 B의 `inDegree`가 0이 되었다면? B도 큐에 넣는다.

### 위상정렬 구현


```c++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    
    // 1. 그래프와 진입 차수(inDegree) 테이블 생성
    vector<vector<int>> graph(n + 1);
    vector<int> inDegree(n + 1, 0);

    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        graph[a].push_back(b); // a 뒤에 b가 선다
        inDegree[b]++;         // b의 진입 차수 증가 (내 앞에 한 명 더 생김)
    }

    // 2. 진입 차수가 0인(바로 줄 서도 되는) 학생 큐에 넣기
    queue<int> q;
    for(int i = 1; i <= n; i++){
        if(inDegree[i] == 0) {
            q.push(i);
        }
    }

    // 3. 큐가 빌 때까지 반복 (위상 정렬 수행)
    while(!q.empty()){
        // 1. 큐에서 학생(cur)을 꺼내고 출력한다.
        int cur = q.front();
        cout << cur << " ";
        q.pop();

        // 2. graph[cur]에 연결된 다음 학생(next)들의 inDegree를 1 줄인다.
        for(int next : graph[cur]){
            inDegree[next]--;
            // 3. 만약 inDegree가 0이 된 학생이 있다면 큐에 넣는다.
            if(inDegree[next] == 0){
                q.push(next);
            }
        }
    }

    return 0;
}
```

